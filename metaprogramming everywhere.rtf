{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf370
{\fonttbl\f0\fnil\fcharset0 Inconsolata;}
{\colortbl;\red255\green255\blue255;}
\margl1440\margr1440\vieww16600\viewh10560\viewkind0
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural

\f0\fs40 \cf0 metaprogram anything	\
\
Hydra's parser is not, in general, the actual parser used by the executing program; the obvious exception would be Clojure, since we're writing Hydra in it. \
\
This lets us do some deep voodoo. First, let's talk about languages and dialects. What's the difference in a computer science context? Programming languages don't have their own Navy, making the traditional definition hard to work with.\
\
In Hydra land, a language is an external program that compiles, interprets, or otherwise interacts with a codebase. Read that again; gcc and clang/llvm are different languages under that definition. Australia and America also have their own navies; the world is not a tidy place.\
\
How do we make two different parsers for, say, Firefox-JS and Chrome-JS? Welcome to Hydra! We create a common reference grammar, branch it, make the language specific changes in the branches, and make the language-common changes in the trunk with propagation to the branches. \
\
So far so good; on to dialects. In Hydra terms, a dialect is a Hydra-specific parser that has been modified so as to differ from the target language. In such cases, the parser must be supplemented with code-transformation rules that produce the target language.\
\
Let's discuss a simple example. You're writing JavaScript, and you want a simple type checker. So you define a new dialect, called JSType, which lets you match this kind of statement:\
\
var foo is 'int';\
\
or \
\
var foo is 'int' = 5;\
\
Note that I've decided my janky type is a literal string. That's to avoid visual confusion. I added a keyword, but you could probably still get away with having an 'is' variable in the global namespace, since the parser will only look for 'is' between a variable declaration and a string, or if elsewhere, in specific places.\
\
So if we write a function\
\
(function(foo is int, bar) \{...\}())\
\
it will only accept a foo if it's of "type" int. \
\
All of the new tokens and rules are put in a separate channel, so for this deliberately simple case, there is no need to modify the code stream. For the statement\
\
var foo is 'int' = 4;\
\
We merely remove the tokens 'is' and "'int'", giving us\
\
var foo = 4;\
\
and similarly (function(foo is in, bar) \{...\}()\} becomes \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural
\cf0 (function(foo, bar) \{...\}()\}\
\
However, our *editor* will not let us call the function using a variable which has not been asserted to be of type 'int'. If we go into permissive mode and try and insist, it will complain; the only way out is to tell the editor that you're speaking plain JS, at which point it will decide 'is' is a var and that 'int' is a parsing error. \
\
This is a deliberately simple/naive example, meant to point out that Hydra itself is, perforce, a language development environment. Something like Coffeescript could readily be developed as a dialect of Javascript in Hydra; since the editor is responsible for the resulting code transformation, source mapping and REPL type behaviours could be preserved across the entire process of dialect development. \
\
This will prove powerful and liberating. Want to add a rule that certain kinds of comments contain Markdown? Done. Every parser transformation is an OT on a Hydra code base, meaning that when the main line parser for your language changes or improves, you can propagate those changes into your own dialect. This should work excellently in the general case, since changing programming languages is done with a keen eye towards preserving backwards compatibility on the parse tree level. \
\
}