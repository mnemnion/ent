Justification of the Components.

Hydra is a many headed beast. In this precis I'll go over why the components that have been chosen, are chosen.

Clojure

We'll start at the heart: the Hydra engine will be written in Clojure, and run on the JVM. This is a straightforward case of using the right tool for the job.

Lispy languages are powerful and general, and there is a use case for which they should be the default: manipulation of string-represented abstract syntax trees. 

Of the Lisps, we choose Clojure because of its attitude towards mutability. Mutable state is a severe liability in Hydra, and we want a language that defaults to immutability. That eliminates Schemes and Common Lisp, leaving us at a stroke with Clojure. 

There is another candidate: the family of languages I'll just call Haskell to show my near-total unfamiliarity on an applied level. Since I'm architecting Hydra, that's one of the actual reasons not to use it. 

The other reasons are firmer and less incidental. Haskell is an immensely powerful tool for functional programming, but the abstractions that make it powerful are counter to our purposes. 

Hydra is built on transformation of an abstract tree, the values of which are ultimately immutable strings in Unicode. Other types will be used, surely, but this is the sine qua non of Hydra. 

That happens to be the exact structure of Clojure, which is no accident; mathematics is its own argument. Type inference and safety can't really help you when your 'type' is a highly context dependent judgement call about a Unicode string. 

Because Clojure, therefore, the JVM. As a result, we will begin with the Antlr4 library for specifying grammars and generating parse trees. An early goal of the Controller branch of the project will be modifying Antlr to be Clojure compatible: the end result will use Clojure's immutable data types in the Java code, and emit pure Clojure for walking and interacting with the syntax tree. 

This can be expected to work. At present, most grammars can be handled in pure Antlr, such that the resulting Java needs a thin wrap of Clojure to be used for our purposes. When it is necessary to embed Java outputs into the grammar (which Antlr4 is designed to make very unusual, but must perforce be allowed), we use Clojure data types and generate wrappers. Antlr must be digested into the project as soon as possible; this can only be good for Antlr, which would benefit from the immutability and functional paradigm of Clojure data structures and their associated access methods. 

JSON is trivial in pure Antlr, and all of what makes Hydra distinctive can be demonstrated with JSON as the target language. 

This just in: there's a new parsing library called instaparse that's native Clojure and looks very general and all around excellent. Go figure. 

The View

Hydra will be rendered using a rendering engine, with all UI in HTML/CSS/Javascript. The JS might be Clojurescript, it might be Coffeescript, I don't care much, and Crockford flavoured Javascript has a purity that I admire. I'm wary of any abstraction layer that Hydra might not need, since it has so many that are absolutely necessary. 

I intend that Hydra be a three developer team, because I could spend a lifetime learning what I'd need to in order to write the view, and I'm needed for the Controller.

That said, why aren't we using a Java gui? Besides that they suck. I consider this one obvious: the web standards work everywhere, support client-server separation, and allow for beautiful and consistent user experience, that can be modified in arbitrary ways by armies of trained desiners. 

It also means Hydra will have a JS engine as well as a JRE, giving two choices of target machines for evaluation. An Enscripten layer to get to V8Monkey, or any of the bajillion ports of every language in existence to the JVM. That's close enough to total coverage that languages not supported should be ported, rather than their engines added. 

Someone could make a passionate case for the LLVM and we might listen. Enscripten is pretty good though, especially if we can get on board with a rendering engine that supports asm.js. 

I'm pretending the View will be node-webkit, but it could be appjs or geckomonkey. I will use node-webkit for mockups and leave the real choice to the eventual expert.

The Model.

I got nothing here. Databases are where I'm weakest, followed by networking. I like parsing, tree transformation, and persistence in theory. Persistence in practice is messy and I don't even have an opinion at the moment on NoSQL vs anything else. 

If I had to do it, the persistence would be in flat text files that get flashed to Git along with everything else. This would probably be horrible? Someone who knows, help me out. 